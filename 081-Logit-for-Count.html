<!DOCTYPE html>
<html >

<head>

  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>Классификация, регрессия и другие алгоритмы Data Mining с использованием R</title>
  <meta content="text/html; charset=UTF-8" http-equiv="Content-Type">
  <meta name="description" content="Реализация алгоритмов Data Mining с использованием R">
  <meta name="generator" content="bookdown 0.3 and GitBook 2.6.7">

  <meta property="og:title" content="Классификация, регрессия и другие алгоритмы Data Mining с использованием R" />
  <meta property="og:type" content="book" />
  <meta property="og:url" content="https://ranalytics.github.io/data-mining/" />
  
  <meta property="og:description" content="Реализация алгоритмов Data Mining с использованием R" />
  <meta name="github-repo" content="ranalytics/data-mining" />

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="Классификация, регрессия и другие алгоритмы Data Mining с использованием R" />
  
  <meta name="twitter:description" content="Реализация алгоритмов Data Mining с использованием R" />
  

<meta name="author" content="Шитиков В. К., Мастицкий С. Э.">


<meta name="date" content="2017-04-07">

  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  
  
<link rel="prev" href="076-NN.html">
<link rel="next" href="082-NN-with-Caret.html">

<script src="libs/jquery-2.2.3/jquery.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />









<style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
</style>

</head>

<body>


  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li class="chapter" data-level="" data-path="index.html"><a href="index.html"><i class="fa fa-check"></i>Аннотация</a></li>
<li class="chapter" data-level="1" data-path="01-Data-Mining-Models-in-R.html"><a href="01-Data-Mining-Models-in-R.html"><i class="fa fa-check"></i><b>1</b> Реализация моделей Data Mining в среде R (вместо предисловия)</a><ul>
<li class="chapter" data-level="1.1" data-path="01-Data-Mining-Models-in-R.html"><a href="01-Data-Mining-Models-in-R.html#section_1_1"><i class="fa fa-check"></i><b>1.1</b> Data Mining как направление анализа данных</a><ul>
<li class="chapter" data-level="1.1.1" data-path="01-Data-Mining-Models-in-R.html"><a href="01-Data-Mining-Models-in-R.html#sec_1_1_1"><i class="fa fa-check"></i><b>1.1.1</b> От статистического анализа разового эксперимента к Data Mining</a></li>
<li class="chapter" data-level="1.1.2" data-path="01-Data-Mining-Models-in-R.html"><a href="01-Data-Mining-Models-in-R.html#sec_1_1_2"><i class="fa fa-check"></i><b>1.1.2</b> Принципиальная множественность моделей окружающего мира</a></li>
<li class="chapter" data-level="1.1.3" data-path="01-Data-Mining-Models-in-R.html"><a href="01-Data-Mining-Models-in-R.html#sec_1_1_3"><i class="fa fa-check"></i><b>1.1.3</b> Нарастающая множественность алгоритмов построения моделей</a></li>
<li class="chapter" data-level="1.1.4" data-path="01-Data-Mining-Models-in-R.html"><a href="01-Data-Mining-Models-in-R.html#sec_1_1_4"><i class="fa fa-check"></i><b>1.1.4</b> Типы и характеристики групп моделей Data Mining</a></li>
<li class="chapter" data-level="1.1.5" data-path="01-Data-Mining-Models-in-R.html"><a href="01-Data-Mining-Models-in-R.html#sec_1_1_5"><i class="fa fa-check"></i><b>1.1.5</b> Природа многомерного отклика и его моделирование</a></li>
</ul></li>
<li class="chapter" data-level="1.2" data-path="012-R-Intro.html"><a href="012-R-Intro.html"><i class="fa fa-check"></i><b>1.2</b> Статистическая среда R и ее использование в Data Mining</a></li>
<li class="chapter" data-level="1.3" data-path="013-What-This-Book-Is-About.html"><a href="013-What-This-Book-Is-About.html"><i class="fa fa-check"></i><b>1.3</b> О чем эта книга и чего в ней нет</a></li>
</ul></li>
<li class="chapter" data-level="2" data-path="021-Model-Quality-Criteria.html"><a href="021-Model-Quality-Criteria.html"><i class="fa fa-check"></i><b>2</b> Статистические модели: критерии и методы оценивания их качества</a><ul>
<li class="chapter" data-level="2.1" data-path="021-Model-Quality-Criteria.html"><a href="021-Model-Quality-Criteria.html#sec_2_1"><i class="fa fa-check"></i><b>2.1</b> Основные шаги построения и верификации моделей</a></li>
<li class="chapter" data-level="2.2" data-path="022-Resampling-Techniques.html"><a href="022-Resampling-Techniques.html"><i class="fa fa-check"></i><b>2.2</b> Использование алгоритмов ресэмплинга для тестирования моделей и оптимизации их параметров</a></li>
<li class="chapter" data-level="2.3" data-path="023-Models-for-Class-Prediction.html"><a href="023-Models-for-Class-Prediction.html"><i class="fa fa-check"></i><b>2.3</b> Модели для предсказания класса объектов</a></li>
<li class="chapter" data-level="2.4" data-path="024-Projecting-Data-onto-a-Plane.html"><a href="024-Projecting-Data-onto-a-Plane.html"><i class="fa fa-check"></i><b>2.4</b> Проецирование многомерных данных на плоскости</a></li>
<li class="chapter" data-level="2.5" data-path="025-MV-analysis.html"><a href="025-MV-analysis.html"><i class="fa fa-check"></i><b>2.5</b> Многомерный статистический анализ данных</a></li>
<li class="chapter" data-level="2.6" data-path="026-Clustering-Methods.html"><a href="026-Clustering-Methods.html"><i class="fa fa-check"></i><b>2.6</b> Методы кластеризации</a></li>
</ul></li>
<li class="chapter" data-level="3" data-path="031-Intro-to-Caret.html"><a href="031-Intro-to-Caret.html"><i class="fa fa-check"></i><b>3</b> Пакет <code>caret</code> - инструмент построения статистических моделей в R</a><ul>
<li class="chapter" data-level="3.1" data-path="031-Intro-to-Caret.html"><a href="031-Intro-to-Caret.html#---------caret"><i class="fa fa-check"></i><b>3.1</b> Универсальный интерфейс доступа к функциям машинного обучения в пакете <code id="sec_3_1">caret</code></a></li>
<li class="chapter" data-level="3.2" data-path="032-Removing-Predictors.html"><a href="032-Removing-Predictors.html"><i class="fa fa-check"></i><b>3.2</b> Обнаружение и удаление “ненужных” предикторов</a></li>
<li class="chapter" data-level="3.3" data-path="033-Preprocessing.html"><a href="033-Preprocessing.html"><i class="fa fa-check"></i><b>3.3</b> Предварительная обработка: преобразование и групповая трансформация переменных</a></li>
<li class="chapter" data-level="3.4" data-path="034-Handling-Missing-Values.html"><a href="034-Handling-Missing-Values.html"><i class="fa fa-check"></i><b>3.4</b> Заполнение пропущенных значений в данных</a></li>
<li class="chapter" data-level="3.5" data-path="035-The-train-Functions.html"><a href="035-The-train-Functions.html"><i class="fa fa-check"></i><b>3.5</b> Функция <code>train()</code> из пакета <code id="sec_3_5">caret</code></a></li>
</ul></li>
<li class="chapter" data-level="4" data-path="041-Regression-Models.html"><a href="041-Regression-Models.html"><i class="fa fa-check"></i><b>4</b> Построение регрессионных моделей различного типа</a><ul>
<li class="chapter" data-level="4.1" data-path="041-Regression-Models.html"><a href="041-Regression-Models.html#sec_4_1"><i class="fa fa-check"></i><b>4.1</b> Селекция оптимального набора предикторов линейной модели</a><ul>
<li class="chapter" data-level="4.1.1" data-path="041-Regression-Models.html"><a href="041-Regression-Models.html#sec_4_1_1"><i class="fa fa-check"></i><b>4.1.1</b> Полная регрессионная модель и пошаговая процедура</a></li>
<li class="chapter" data-level="4.1.2" data-path="041-Regression-Models.html"><a href="041-Regression-Models.html#sec_4_1_2"><i class="fa fa-check"></i><b>4.1.2</b> Рекурсивное исключение переменных</a></li>
<li class="chapter" data-level="4.1.3" data-path="041-Regression-Models.html"><a href="041-Regression-Models.html#sec_4_1_3"><i class="fa fa-check"></i><b>4.1.3</b> Генетический алгоритм</a></li>
<li class="chapter" data-level="4.1.4" data-path="041-Regression-Models.html"><a href="041-Regression-Models.html#sec_4_1_4"><i class="fa fa-check"></i><b>4.1.4</b> Тестирование моделей с использованием дополнительного набора данных</a></li>
</ul></li>
<li class="chapter" data-level="4.2" data-path="042-Regularization.html"><a href="042-Regularization.html"><i class="fa fa-check"></i><b>4.2</b> Регуляризация, частные наименьшие квадраты и kNN-регрессия</a><ul>
<li class="chapter" data-level="4.2.1" data-path="042-Regularization.html"><a href="042-Regularization.html#sec_4_2_1"><i class="fa fa-check"></i><b>4.2.1</b> Регрессия по методу “лассо”</a></li>
<li class="chapter" data-level="4.2.2" data-path="042-Regularization.html"><a href="042-Regularization.html#sec_4_2_2"><i class="fa fa-check"></i><b>4.2.2</b> Метод частных наименьших квадратов (PLS)</a></li>
<li class="chapter" data-level="4.2.3" data-path="042-Regularization.html"><a href="042-Regularization.html#sec_4_2_3"><i class="fa fa-check"></i><b>4.2.3</b> Регрессия по методу <em>k</em> ближайших соседей</a></li>
<li class="chapter" data-level="4.2.4" data-path="042-Regularization.html"><a href="042-Regularization.html#sec_4_2_4"><i class="fa fa-check"></i><b>4.2.4</b> Тестирование моделей с использованием дополнительного набора данных</a></li>
</ul></li>
<li class="chapter" data-level="4.3" data-path="043-Decision-Trees.html"><a href="043-Decision-Trees.html"><i class="fa fa-check"></i><b>4.3</b> Построение деревьев регрессии</a><ul>
<li class="chapter" data-level="4.3.1" data-path="043-Decision-Trees.html"><a href="043-Decision-Trees.html#sec_4_3_1"><i class="fa fa-check"></i><b>4.3.1</b> Построение деревьев на основе рекурсивного разбиения</a></li>
<li class="chapter" data-level="4.3.2" data-path="043-Decision-Trees.html"><a href="043-Decision-Trees.html#sec_4_3_2"><i class="fa fa-check"></i><b>4.3.2</b> Построение деревьев с использованием алгортма условного вывода</a></li>
<li class="chapter" data-level="4.3.3" data-path="043-Decision-Trees.html"><a href="043-Decision-Trees.html#sec_4_3_3"><i class="fa fa-check"></i><b>4.3.3</b> Тестирование моделей с использованием дополнительного набора данных</a></li>
</ul></li>
<li class="chapter" data-level="4.4" data-path="044-Ensembles.html"><a href="044-Ensembles.html"><i class="fa fa-check"></i><b>4.4</b> Ансамбли моделей: бэггинг, случайные леса, бустинг</a><ul>
<li class="chapter" data-level="4.4.1" data-path="044-Ensembles.html"><a href="044-Ensembles.html#sec_4_4_1"><i class="fa fa-check"></i><b>4.4.1</b> Бэггинг и случайные леса</a></li>
<li class="chapter" data-level="4.4.2" data-path="044-Ensembles.html"><a href="044-Ensembles.html#sec_4_4_2"><i class="fa fa-check"></i><b>4.4.2</b> Бустинг</a></li>
<li class="chapter" data-level="4.4.3" data-path="044-Ensembles.html"><a href="044-Ensembles.html#sec_4_4_3"><i class="fa fa-check"></i><b>4.4.3</b> Тестирование моделей с использованием дополнительного набора данных</a></li>
</ul></li>
<li class="chapter" data-level="4.5" data-path="045-Comparing-Trees.html"><a href="045-Comparing-Trees.html"><i class="fa fa-check"></i><b>4.5</b> Сравнение построенных моделей и оценка информативности предикторов</a></li>
<li class="chapter" data-level="4.6" data-path="046-MV-Trees.html"><a href="046-MV-Trees.html"><i class="fa fa-check"></i><b>4.6</b> Деревья регрессии с многомерным откликом</a></li>
</ul></li>
<li class="chapter" data-level="5" data-path="051-Association-Rules.html"><a href="051-Association-Rules.html"><i class="fa fa-check"></i><b>5</b> Бинарные матрицы и ассоциативные правила</a><ul>
<li class="chapter" data-level="5.1" data-path="051-Association-Rules.html"><a href="051-Association-Rules.html#sec_5_1"><i class="fa fa-check"></i><b>5.1</b> Классификация в бинарных пространствах с использованием классических моделей</a></li>
<li class="chapter" data-level="5.2" data-path="052-Binary-Decision-Trees.html"><a href="052-Binary-Decision-Trees.html"><i class="fa fa-check"></i><b>5.2</b> Бинарные деревья решений</a></li>
<li class="chapter" data-level="5.3" data-path="053-Logic-Rules.html"><a href="053-Logic-Rules.html"><i class="fa fa-check"></i><b>5.3</b> Поиск логических закономерностей в данных</a></li>
<li class="chapter" data-level="5.4" data-path="054-Association-Rules-Algos.html"><a href="054-Association-Rules-Algos.html"><i class="fa fa-check"></i><b>5.4</b> Алгоритмы выделения ассоциативных правил</a></li>
<li class="chapter" data-level="5.5" data-path="055-Traminer.html"><a href="055-Traminer.html"><i class="fa fa-check"></i><b>5.5</b> Анализ последовательностей знаков или событий</a></li>
</ul></li>
<li class="chapter" data-level="6" data-path="061-Binary-Classifiers.html"><a href="061-Binary-Classifiers.html"><i class="fa fa-check"></i><b>6</b> Бинарные классификаторы с различными разделяющими поверхностями</a><ul>
<li class="chapter" data-level="6.1" data-path="061-Binary-Classifiers.html"><a href="061-Binary-Classifiers.html#sec_6_1"><i class="fa fa-check"></i><b>6.1</b> Дискриминантный анализ</a></li>
<li class="chapter" data-level="6.2" data-path="062-SVM.html"><a href="062-SVM.html"><i class="fa fa-check"></i><b>6.2</b> Метод опорных векторов</a></li>
<li class="chapter" data-level="6.3" data-path="063-Nonlinear-Borders.html"><a href="063-Nonlinear-Borders.html"><i class="fa fa-check"></i><b>6.3</b> Ядерные функции машины опорных векторов</a></li>
<li class="chapter" data-level="6.4" data-path="064-Classification-Trees.html"><a href="064-Classification-Trees.html"><i class="fa fa-check"></i><b>6.4</b> Деревья классификации, случайный лес и логистическая регрессия</a></li>
<li class="chapter" data-level="6.5" data-path="065-Comparing-Classifiers.html"><a href="065-Comparing-Classifiers.html"><i class="fa fa-check"></i><b>6.5</b> Процедуры сравнения эффективности моделей классификации</a></li>
</ul></li>
<li class="chapter" data-level="7" data-path="071-Multiclass-Classification.html"><a href="071-Multiclass-Classification.html"><i class="fa fa-check"></i><b>7</b> Модели классификации для нескольких классов</a><ul>
<li class="chapter" data-level="7.1" data-path="071-Multiclass-Classification.html"><a href="071-Multiclass-Classification.html#sec_7_1"><i class="fa fa-check"></i><b>7.1</b> Ирисы Фишера и метод <em>k</em> ближайших соседей</a></li>
<li class="chapter" data-level="7.2" data-path="072-NBC.html"><a href="072-NBC.html"><i class="fa fa-check"></i><b>7.2</b> Наивный байесовский классификатор</a></li>
<li class="chapter" data-level="7.3" data-path="073-In-Discriminant-Space.html"><a href="073-In-Discriminant-Space.html"><i class="fa fa-check"></i><b>7.3</b> Классификация в линейном дискриминантном пространстве</a></li>
<li class="chapter" data-level="7.4" data-path="074-Nonlinear-Classifiers.html"><a href="074-Nonlinear-Classifiers.html"><i class="fa fa-check"></i><b>7.4</b> Нелинейные классификаторы в R</a></li>
<li class="chapter" data-level="7.5" data-path="075-Multinomial-Logit.html"><a href="075-Multinomial-Logit.html"><i class="fa fa-check"></i><b>7.5</b> Модель мультиномиального логита</a></li>
<li class="chapter" data-level="7.6" data-path="076-NN.html"><a href="076-NN.html"><i class="fa fa-check"></i><b>7.6</b> Классификаторы на основе искусственных нейронных сетей</a></li>
</ul></li>
<li class="chapter" data-level="8" data-path="081-Logit-for-Count.html"><a href="081-Logit-for-Count.html"><i class="fa fa-check"></i><b>8</b> Моделирование порядковых и счетных переменных</a><ul>
<li class="chapter" data-level="8.1" data-path="081-Logit-for-Count.html"><a href="081-Logit-for-Count.html#sec_8_1"><i class="fa fa-check"></i><b>8.1</b> Модель логита для порядковой переменной</a></li>
<li class="chapter" data-level="8.2" data-path="082-NN-with-Caret.html"><a href="082-NN-with-Caret.html"><i class="fa fa-check"></i><b>8.2</b> Настройка параметров нейронных сетей средствами пакета <code id="sec_8_2">caret</code></a></li>
<li class="chapter" data-level="8.3" data-path="083-Model-Complexes.html"><a href="083-Model-Complexes.html"><i class="fa fa-check"></i><b>8.3</b> Методы комплексации модельных прогнозов</a></li>
<li class="chapter" data-level="8.4" data-path="084-GLM-for-Counts.html"><a href="084-GLM-for-Counts.html"><i class="fa fa-check"></i><b>8.4</b> Обобщенные линейные модели для счетных данных</a></li>
<li class="chapter" data-level="8.5" data-path="085-ZIP-for-Counts.html"><a href="085-ZIP-for-Counts.html"><i class="fa fa-check"></i><b>8.5</b> ZIP- и барьерные модели счетных данных</a></li>
</ul></li>
<li class="chapter" data-level="9" data-path="091-Data-Transformation.html"><a href="091-Data-Transformation.html"><i class="fa fa-check"></i><b>9</b> Методы многомерной ординации</a><ul>
<li class="chapter" data-level="9.1" data-path="091-Data-Transformation.html"><a href="091-Data-Transformation.html#sec_9_1"><i class="fa fa-check"></i><b>9.1</b> Преобразование данных и вычисление матрицы расстояний</a></li>
<li class="chapter" data-level="9.2" data-path="092-Distance-ANOVA.html"><a href="092-Distance-ANOVA.html"><i class="fa fa-check"></i><b>9.2</b> Непараметрический дисперсионный анализ матриц дистанций</a></li>
<li class="chapter" data-level="9.3" data-path="093-Comparing-Diagrams.html"><a href="093-Comparing-Diagrams.html"><i class="fa fa-check"></i><b>9.3</b> Методы ординации объектов и переменных: построение и сравнение диаграмм</a></li>
<li class="chapter" data-level="9.4" data-path="094-Ordination-Factors.html"><a href="094-Ordination-Factors.html"><i class="fa fa-check"></i><b>9.4</b> Оценка связи ординации с внешними факторами</a></li>
<li class="chapter" data-level="9.5" data-path="095-NMDS.html"><a href="095-NMDS.html"><i class="fa fa-check"></i><b>9.5</b> Неметрическое многомерное шкалирование и построение распределения чувствительности видов</a></li>
</ul></li>
<li class="chapter" data-level="10" data-path="101-Partitioning-Algos.html"><a href="101-Partitioning-Algos.html"><i class="fa fa-check"></i><b>10</b> Кластерный анализ</a><ul>
<li class="chapter" data-level="10.1" data-path="101-Partitioning-Algos.html"><a href="101-Partitioning-Algos.html#sec_10_1"><i class="fa fa-check"></i><b>10.1</b> Алгоритмы кластеризации, основанные на разделении</a></li>
<li class="chapter" data-level="10.2" data-path="102-H-Clustering.html"><a href="102-H-Clustering.html"><i class="fa fa-check"></i><b>10.2</b> Иерархическая кластеризация</a></li>
<li class="chapter" data-level="10.3" data-path="103-Clustering-Quality.html"><a href="103-Clustering-Quality.html"><i class="fa fa-check"></i><b>10.3</b> Оценка качества кластеризации</a></li>
<li class="chapter" data-level="10.4" data-path="104-Other-Clustering-Methods.html"><a href="104-Other-Clustering-Methods.html"><i class="fa fa-check"></i><b>10.4</b> Другие алгоритмы кластеризации</a><ul>
<li class="chapter" data-level="10.4.1" data-path="104-Other-Clustering-Methods.html"><a href="104-Other-Clustering-Methods.html#sec_10_4_1"><i class="fa fa-check"></i><b>10.4.1</b> Иерархическая кластеризация на главные компоненты</a></li>
<li class="chapter" data-level="10.4.2" data-path="104-Other-Clustering-Methods.html"><a href="104-Other-Clustering-Methods.html#sec_10_4_2"><i class="fa fa-check"></i><b>10.4.2</b> Метод нечетких <em>k</em> средних (fuzzy analysis clustering)</a></li>
<li class="chapter" data-level="10.4.3" data-path="104-Other-Clustering-Methods.html"><a href="104-Other-Clustering-Methods.html#sec_10_4_3"><i class="fa fa-check"></i><b>10.4.3</b> Статистическая модель кластеризации</a></li>
</ul></li>
<li class="chapter" data-level="10.5" data-path="105-Cohonen-Maps.html"><a href="105-Cohonen-Maps.html"><i class="fa fa-check"></i><b>10.5</b> Самоорганизующиеся карты Кохонена</a></li>
</ul></li>
<li class="chapter" data-level="11" data-path="111-Rattle-Intro.html"><a href="111-Rattle-Intro.html"><i class="fa fa-check"></i><b>11</b> <code>rattle</code>: графический интерфейс R для реализации алгоритмов Data Mining</a><ul>
<li class="chapter" data-level="11.1" data-path="111-Rattle-Intro.html"><a href="111-Rattle-Intro.html#----rattle"><i class="fa fa-check"></i><b>11.1</b> Начало работы с пакетом <code id="sec_11_1">rattle</code></a></li>
<li class="chapter" data-level="11.2" data-path="112-Descriptive-Stats.html"><a href="112-Descriptive-Stats.html"><i class="fa fa-check"></i><b>11.2</b> Описательная статистика и визуализация данных</a></li>
<li class="chapter" data-level="11.3" data-path="113-Model-Building.html"><a href="113-Model-Building.html"><i class="fa fa-check"></i><b>11.3</b> Построение и тестирование моделей классификации</a></li>
<li class="chapter" data-level="11.4" data-path="114-Descriptive-Models.html"><a href="114-Descriptive-Models.html"><i class="fa fa-check"></i><b>11.4</b> Дескриптивные модели (обучение без учителя)</a><ul>
<li class="chapter" data-level="11.4.1" data-path="114-Descriptive-Models.html"><a href="114-Descriptive-Models.html#sec_11_4_1"><i class="fa fa-check"></i><b>11.4.1</b> Кластерный анализ</a></li>
<li class="chapter" data-level="11.4.2" data-path="114-Descriptive-Models.html"><a href="114-Descriptive-Models.html#sec_11_4_2"><i class="fa fa-check"></i><b>11.4.2</b> Ассоциативные правила</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="12" data-path="120-References.html"><a href="120-References.html"><i class="fa fa-check"></i><b>12</b> Список рекомендуемой литературы</a></li>
<li class="chapter" data-level="" data-path="130-Appendix.html"><a href="130-Appendix.html"><i class="fa fa-check"></i>Приложение: cправочная карта по Data Mining с использованием R</a></li>
</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">Классификация, регрессия и другие алгоритмы Data Mining с использованием R</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="ch_8" class="section level1">
<h1><span class="header-section-number">ГЛАВА 8</span> Моделирование порядковых и счетных переменных</h1>
<div id="sec_8_1" class="section level2">
<h2><span class="header-section-number">8.1</span> Модель логита для порядковой переменной</h2>
<p>Если категории отклика являются упорядоченными, то можно воспользоваться этой дополнительной информацией и построить потенциально более качественную модель логистической регрессии с более простой интерпретацией результатов, чем модель, основанную на использовании дискретных классов отклика. Пусть для произвольной порядковой случайной величины <span class="math inline">\(Y\)</span>, изменяющейся на интервале от 1 до <span class="math inline">\(J\)</span>, справедливо неравенство</p>
<p><span class="math display">\[P(Y \leq 1 ) \leq P(Y \leq 2) \leq \dots \leq P(Y \leq J),\]</span></p>
<p>определяющее процесс накопления вероятности</p>
<p><span class="math display">\[P(Y \leq 1) = \pi_1+ \dots + \pi_j, \, \,  j = 1, \dots, J.\]</span></p>
<p>Тогда модель для оценки логарифма отношения накопленных шансов, или кумулятивного логита (cumulative logit), будет иметь вид:</p>
<p><span class="math display">\[ \text{logit}[P(Y \leq j)] = \log \left[ \frac{\pi_1 + \dots \pi_j}{\pi_{j+1} + \dots \pi_J} \right] = \alpha + \beta \mathbf{x}, \, \, j = 1, \dots, J-1, \]</span></p>
<p>где параметр <span class="math inline">\(\alpha_j\)</span> определяет величину, на которую увеличивается логарифм отношения шансов при включении вероятности <span class="math inline">\(\pi_j\)</span>, а коэффициенты линейной модели <span class="math inline">\(\beta\)</span> не зависят от номера группы <span class="math inline">\(j\)</span> и отражают эффекты воздействия независимых переменных. На рис. <a href="081-Logit-for-Count.html#fig:fig-8-1">8.1</a> показан пример такой модели с одинаковым эффектом независимой переменной <span class="math inline">\(x\)</span> на каждую из трех функций накопленных вероятностей отклика с четырьмя категориями: видно, что происходит пропорциональный сдвиг кривых вправо, определяемый величиной коэффициента <span class="math inline">\(\alpha_j\)</span>.</p>
<div class="figure" style="text-align: center"><span id="fig:fig-8-1"></span>
<img src="figures/sigmoids.png" alt="Кривые накопленных вероятностей для модели пропорциональных шансов" width="380px" />
<p class="caption">
Рисунок 8.1: Кривые накопленных вероятностей для модели пропорциональных шансов
</p>
</div>
<p>Мы распрощаемся с ирисами Фишера, классы которого независимы, и рассмотрим пример модели кумулятивного логита на основе данных о популяции вкусных брюхоногих моллюсков - морских ушек (<em>Haliotis species</em>). Выборка из 8 морфометрических показателей 4177 особей этого вида, отловленных у берегов Тасмании, также может быть скачана из архива <a href="http://archive.ics.uci.edu/ml/">UCI Machine Learning Repository</a>. Возраст моллюсков определяют, прорисовывая и окрашивая раковину по конусу, после чего подсчитывают число колец под микроскопом. Это - скучная и отнимающая много времени работа, поэтому ставится задача предсказания возраста морского ушка по физическим измерениям.</p>
<p><img src="figures/molluscs.jpg" width="280px" style="display: block; margin: auto;" /></p>
<p>Познакомимся с анализируемой выборкой:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">abalone &lt;-<span class="st"> </span><span class="kw">read.csv</span>(<span class="st">&quot;data/abalone.data&quot;</span>, <span class="dt">header =</span> <span class="ot">FALSE</span>)
<span class="kw">names</span>(abalone) &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;пол&quot;</span>, <span class="st">&quot;длина&quot;</span>, <span class="st">&quot;диаметр&quot;</span>, <span class="st">&quot;высота&quot;</span>, <span class="st">&quot;вес.общ&quot;</span>,
                    <span class="st">&quot;вес.тела&quot;</span>, <span class="st">&quot;вес.внут&quot;</span>, <span class="st">&quot;вес.рак&quot;</span>, <span class="st">&quot;rings&quot;</span>)
<span class="kw">summary</span>(abalone[, <span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">9</span>)])</code></pre></div>
<pre><code>##  пол          длина           rings       
##  F:1307   Min.   :0.075   Min.   : 1.000  
##  I:1342   1st Qu.:0.450   1st Qu.: 8.000  
##  M:1528   Median :0.545   Median : 9.000  
##           Mean   :0.524   Mean   : 9.934  
##           3rd Qu.:0.615   3rd Qu.:11.000  
##           Max.   :0.815   Max.   :29.000</code></pre>
<p>Показатель <code>rings</code>, который мы не стали переводить на русский язык - упомянутое число возрастных колец на раковине моллюска. Отловленные животные принадлежат к трем группам по показателю пол: мужской (<code>M</code>), женский (<code>F</code>) и ювенильные особи (<code>I</code>). Построим несколько графиков с использованием пакетов <code>ggplot2</code> и <code>ggcorrplot</code>, которые позволяют сделать некоторые важные предварительные выводы. В частности, а) морфометрические показатели сильно коррелируют как между собой и, в несколько меньшей мере, с числом колец <code>rings</code> (рис. <a href="081-Logit-for-Count.html#fig:fig-8-2">8.2</a>), б) между ними существует визуально отчетливая линейная зависимость, имеющая разный коэффициент угла наклона для разных половых групп (рис. <a href="081-Logit-for-Count.html#fig:fig-8-3">8.3</a>):</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">require</span>(ggplot2) ;  <span class="kw">library</span>(ggcorrplot)
<span class="co"># Rорреляционная матрица</span>
M &lt;-<span class="st"> </span><span class="kw">cor</span>(abalone[, <span class="dv">2</span>:<span class="dv">8</span>])
<span class="kw">ggcorrplot</span>(M, <span class="dt">hc.order =</span> <span class="ot">TRUE</span>, <span class="dt">type =</span> <span class="st">&quot;lower&quot;</span>,
           <span class="dt">colors =</span> <span class="kw">c</span>(<span class="st">&quot;white&quot;</span>,<span class="st">&quot;yellow&quot;</span>,<span class="st">&quot;purple&quot;</span> ), <span class="dt">lab =</span> <span class="ot">TRUE</span>)</code></pre></div>
<div class="figure" style="text-align: center"><span id="fig:fig-8-2"></span>
<img src="081-Logit-for-Count_files/figure-html/fig-8-2-1.png" alt="Корреляционная матрица морфометрических показателей" width="576" />
<p class="caption">
Рисунок 8.2: Корреляционная матрица морфометрических показателей
</p>
</div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Линейная зависимость</span>
<span class="kw">ggplot</span>(abalone) +<span class="st"> </span><span class="kw">aes</span>(длина, rings, <span class="dt">color =</span> пол) +
<span class="st">    </span><span class="kw">geom_point</span>() +<span class="st"> </span><span class="kw">labs</span>(<span class="dt">x =</span> <span class="st">&quot;Длина раковины&quot;</span>,
                        <span class="dt">y =</span> <span class="st">&quot;Число колец&quot;</span>, <span class="dt">color =</span> <span class="st">&quot;Пол&quot;</span>) +<span class="st"> </span>
<span class="st">    </span><span class="kw">stat_smooth</span>(<span class="dt">method =</span> <span class="st">&quot;lm&quot;</span>, <span class="dt">se =</span> <span class="ot">FALSE</span>, <span class="dt">size =</span> <span class="dv">2</span>)</code></pre></div>
<div class="figure" style="text-align: center"><span id="fig:fig-8-3"></span>
<img src="081-Logit-for-Count_files/figure-html/fig-8-3-1.png" alt="Зависимость числа колец от длины раковины" width="576" />
<p class="caption">
Рисунок 8.3: Зависимость числа колец от длины раковины
</p>
</div>
<p>Разделим интервал варьирования <code>rings</code> на диапазоны и выделим четыре возрастные группы. С точки зрения теории информации назначение границ предпочтительнее всего осуществить из условия равной численности групп. Рассмотрим предварительно функцию плотности распределения и границы квартилей для возможного разделения (рис. <a href="081-Logit-for-Count.html#fig:fig-8-4">8.4</a>):</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ggplot</span>(abalone) +<span class="st"> </span><span class="kw">aes</span>(rings, <span class="dt">fill =</span> пол) +<span class="st"> </span>
<span class="st">    </span><span class="kw">geom_density</span>(<span class="dt">position =</span> <span class="st">&quot;stack&quot;</span>)+<span class="st"> </span>
<span class="st">    </span><span class="kw">geom_vline</span>(<span class="dt">xintercept =</span> <span class="kw">quantile</span>(abalone$rings, 
                                     <span class="dt">p =</span> <span class="kw">c</span>(<span class="fl">0.25</span>, <span class="fl">0.5</span>, <span class="fl">0.75</span>)),
               <span class="dt">colour =</span> <span class="st">&quot;blue&quot;</span>, <span class="dt">linetype =</span> <span class="dv">5</span>, <span class="dt">size =</span> <span class="fl">1.5</span>)</code></pre></div>
<div class="figure" style="text-align: center"><span id="fig:fig-8-4"></span>
<img src="081-Logit-for-Count_files/figure-html/fig-8-4-1.png" alt="Плотность распределения числа колец раковины и границы квартилей" width="576" />
<p class="caption">
Рисунок 8.4: Плотность распределения числа колец раковины и границы квартилей
</p>
</div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">table</span>(<span class="kw">cut</span>(abalone$rings, 
          <span class="dt">breaks =</span> <span class="kw">quantile</span>(abalone$rings, <span class="kw">c</span>(<span class="dv">0</span>, .<span class="dv">25</span>, .<span class="dv">50</span>, .<span class="dv">75</span>, <span class="dv">1</span>), 
                            <span class="dt">include.lowest =</span> <span class="ot">TRUE</span>)))</code></pre></div>
<pre><code>## 
##   (1,8]   (8,9]  (9,11] (11,29] 
##    1406     689    1121     960</code></pre>
<p>Однако из практических соображений мы несколько скорректируем диапазоны, обозначенные квартилями, переместив объекты с 8 возрастными кольцами в группу более старых особей. Добавим новый столбец Возраст с четырьмя возрастными категориями в исходную таблицу abalone и сохраним ее в преобразованном виде в файле <code>abalone.RData</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">abalone$Возраст &lt;-<span class="st"> </span><span class="kw">cut</span>(abalone$rings, <span class="dt">breaks =</span> <span class="kw">c</span>(<span class="dv">0</span>, <span class="dv">7</span>, <span class="dv">9</span>, <span class="dv">11</span>, <span class="dv">29</span>),
                       <span class="dt">labels =</span> <span class="kw">c</span>(<span class="st">&quot;Q1&quot;</span>, <span class="st">&quot;Q2&quot;</span>, <span class="st">&quot;Q3&quot;</span>, <span class="st">&quot;Q4&quot;</span>), <span class="dt">include.lowest =</span> <span class="ot">TRUE</span>)
<span class="kw">save</span>(abalone, <span class="dt">file=</span><span class="st">&quot;data/abalone.RData&quot;</span>)
<span class="kw">table</span>(abalone$Возраст)</code></pre></div>
<pre><code>## 
##   Q1   Q2   Q3   Q4 
##  839 1257 1121  960</code></pre>
<p>Сама по себе идея перейти от счетной переменной к категориальной переменной-фактору может показаться дискуссионной, но она дает нам возможность приступить к построению моделей с порядковым откликом. Модель кумулятивного логита получим с использованием функции <code>polr()</code> из пакета <code>MASS</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(MASS)
CL.aq &lt;-<span class="st"> </span><span class="kw">polr</span>(Возраст ~<span class="st"> </span>.,  <span class="dt">data =</span> abalone[, -<span class="dv">9</span>])
<span class="kw">summary</span>(CL.aq, <span class="dt">digits =</span> <span class="dv">3</span>)</code></pre></div>
<pre><code>## Call:
## polr(formula = Возраст ~ ., data = abalone[, -9])
## 
## Coefficients:
##             Value Std. Error t value
## полI      -0.9424     0.0934 -10.090
## полM       0.0542     0.0748   0.724
## длина      1.5643     1.6722   0.935
## диаметр    9.2270     2.0472   4.507
## высота    13.4736     2.1206   6.354
## вес.общ    6.3932     0.7897   8.095
## вес.тела -15.3736     0.9126 -16.846
## вес.внут  -7.1420     1.2760  -5.597
## вес.рак    7.3099     1.2157   6.013
## 
## Intercepts:
##       Value   Std. Error t value
## Q1|Q2   4.056   0.326     12.447
## Q2|Q3   6.540   0.341     19.206
## Q3|Q4   8.487   0.344     24.644
## 
## Residual Deviance: 8224.074 
## AIC: 8248.074</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Оценка доверительных интервалов коэффициентов</span>
<span class="kw">confint.default</span>(CL.aq)</code></pre></div>
<pre><code>##                 2.5 %      97.5 %
## полI      -1.12547618  -0.7593602
## полM      -0.09236741   0.2006869
## длина     -1.71315347   4.8417381
## диаметр    5.21461784  13.2394216
## высота     9.31738606  17.6298645
## вес.общ    4.84535657   7.9410052
## вес.тела -17.16223162 -13.5850167
## вес.внут  -9.64297569  -4.6411202
## вес.рак    4.92703181   9.6926746</code></pre>
<p>Заметим, что блок коэффициентов состоит из двух разделов: коэффициенты <span class="math inline">\(\beta\)</span> для независимых переменных и оценки параметра <span class="math inline">\(\alpha\)</span>, корректирующие отношение шансов при каждом шаге объединения альтернатив. Расчет доверительных интервалов показал, что два коэффициента <span class="math inline">\(\beta\)</span> статистически незначимы, поскольку их доверительный интервал включает число 0.</p>
<p>Выше отмечалась высокая мультиколлинеарность данных, т.е. высокая степень взаимной зависимости морфометрических показателей. Считается, что наиболее эффективный путь устранения мультиколлинеарности - исключение из регрессионной модели малозначимых коэффициентов, или, выражаясь точнее, отбор информативного комплекса из <span class="math inline">\(q\)</span> переменных (<span class="math inline">\(q &lt; m\)</span>). Пошаговый регрессионный анализ, выполняемый функцией <code>stepAIC()</code>, представляет собой последовательную процедуру включения и исключения отдельных предикторов в модель, пока не будет достигнута оптимальная регрессия по критерию Акаике.</p>
<p>В результате проведенной пошаговой процедуры был исключен показатель длина, а AIC-критерий уменьшился с 8248 до 8247. Однако последующие итерации не привели к его дальнейшей оптимизации (мы опускаем итоги расчетов, поскольку они незначительно отличаются от приведенных выше). Тест на адекватность полученной модели в целом проведем, сравнивая отношения правдоподобия нуль-модели без параметров (1) и модели <code>CLs.aq</code> (2):</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">CLs.aq &lt;-<span class="st"> </span><span class="kw">stepAIC</span>(CL.aq, <span class="dt">trace =</span> <span class="dv">0</span>)
<span class="kw">summary</span>(CLs.aq, <span class="dt">digits =</span> <span class="dv">3</span>) </code></pre></div>
<pre><code>## Call:
## polr(formula = Возраст ~ пол + диаметр + высота + вес.общ + вес.тела + 
##     вес.внут + вес.рак, data = abalone[, -9])
## 
## Coefficients:
##             Value Std. Error t value
## полI      -0.9362     0.0932 -10.050
## полM       0.0543     0.0748   0.727
## диаметр   10.8596     1.0748  10.104
## высота    13.5475     2.1215   6.386
## вес.общ    6.3884     0.7892   8.095
## вес.тела -15.3126     0.9094 -16.838
## вес.внут  -7.0295     1.2696  -5.537
## вес.рак    7.3018     1.2154   6.008
## 
## Intercepts:
##       Value   Std. Error t value
## Q1|Q2   3.949   0.304     12.985
## Q2|Q3   6.432   0.319     20.167
## Q3|Q4   8.381   0.324     25.877
## 
## Residual Deviance: 8224.946 
## AIC: 8246.946</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">confint.default</span>(CLs.aq) </code></pre></div>
<pre><code>##                 2.5 %      97.5 %
## полI      -1.11880720  -0.7536482
## полM      -0.09222309   0.2008834
## диаметр    8.75300690  12.9662538
## высота     9.38953548  17.7055367
## вес.общ    4.84166899   7.9351000
## вес.тела -17.09499191 -13.5301786
## вес.внут  -9.51779485  -4.5411468
## вес.рак    4.91963761   9.6840239</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">CL0.aq &lt;-<span class="st"> </span><span class="kw">polr</span>(Возраст ~<span class="st"> </span><span class="dv">1</span>,  <span class="dt">data =</span> abalone[, -<span class="dv">9</span>])
<span class="kw">anova</span>(CL0.aq, CLs.aq)</code></pre></div>
<pre><code>## Likelihood ratio tests of ordinal regression models
## 
## Response: Возраст
##                                                              Model
## 1                                                                1
## 2 пол + диаметр + высота + вес.общ + вес.тела + вес.внут + вес.рак
##   Resid. df Resid. Dev   Test    Df LR stat. Pr(Chi)
## 1      4174  11484.659                              
## 2      4166   8224.946 1 vs 2     8 3259.712       0</code></pre>
<p>Модель имеет высокую статистическую значимость, что практически всегда бывает, если число наблюдений превышает несколько тысяч.</p>
<p>Рассмотрим теперь эффективность использования построенной модели для прогнозирования возраста моллюсков. С помощью функции <code>fitted()</code> найдем значения вероятностей для каждой из 4 рассматриваемых градаций, которые вычисляются на основе оценок коэффициентов <span class="math inline">\(\alpha_j\)</span> и <span class="math inline">\(\beta\)</span> для модели <code>CLs.aq</code>. Отнесение каждого объекта выборки к конкретной возрастной категории будем осуществлять по максимальной вероятности. Как всегда, функция <code>table()</code> поможет нам выделить несовпадение действительных и предсказанных значений возрастных категорий.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">Probs &lt;-<span class="st"> </span><span class="kw">fitted</span>(CLs.aq)
<span class="kw">head</span>(Probs, <span class="dv">3</span>)</code></pre></div>
<pre><code>##           Q1        Q2         Q3         Q4
## 1 0.16982105 0.5401767 0.23502603 0.05497617
## 2 0.42821924 0.4714134 0.08472626 0.01564114
## 3 0.03303907 0.2572052 0.45143960 0.25831610</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co">#  Построение матрицы неточностей &quot;Факт-Прогноз&quot;</span>
pred &lt;-<span class="st"> </span><span class="kw">apply</span>(Probs, <span class="dv">1</span>, function(x) <span class="kw">colnames</span>(Probs)[<span class="kw">which</span>(x ==<span class="st"> </span><span class="kw">max</span>(x))])
(<span class="kw">table</span>(Факт =<span class="st"> </span>abalone$Возраст, Прогноз =<span class="st"> </span>pred))</code></pre></div>
<pre><code>##     Прогноз
## Факт  Q1  Q2  Q3  Q4
##   Q1 589 233  14   3
##   Q2 113 773 306  65
##   Q3  22 379 446 274
##   Q4   6 144 292 518</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">Acc &lt;-<span class="st"> </span><span class="kw">mean</span>(pred ==<span class="st"> </span>abalone$Возраст)
<span class="kw">paste</span>(<span class="st">&quot;Точность=&quot;</span>, <span class="kw">round</span>(<span class="dv">100</span>*Acc, <span class="dv">2</span>), <span class="st">&quot;%&quot;</span>, <span class="dt">sep =</span> <span class="st">&quot;&quot;</span>)</code></pre></div>
<pre><code>## [1] &quot;Точность=55.69%&quot;</code></pre>
<p>Можно отметить, что модель недостаточно хорошо справилась с предсказанием смежных возрастных категорий.</p>
<p>Многомерность параметров модели не позволяет показать графически изменение вероятности классов в зависимости от значений всех предикторов одновременно. Распространено мнение, что это можно сделать для отдельных предикторов, если зафиксировать значения остальных независимых переменных на уровне их средних значений. Выполним такой частный анализ, например, для диаметра раковины (см. рис. <a href="081-Logit-for-Count.html#fig:fig-8-5">8.5</a>):</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co">#   Подготовка данных для графика</span>
VM &lt;-<span class="st"> </span><span class="kw">apply</span>(abalone[, <span class="dv">2</span>:<span class="dv">8</span>], <span class="dv">2</span>, mean)
d.plot &lt;-<span class="st"> </span><span class="kw">as.data.frame</span>(<span class="kw">matrix</span>(VM, <span class="dt">ncol =</span> <span class="dv">7</span>, <span class="dt">nrow =</span> <span class="dv">50</span>,
                               <span class="dt">byrow =</span> <span class="ot">TRUE</span>, 
                               <span class="dt">dimnames =</span> <span class="kw">list</span>(<span class="dv">1</span>:<span class="dv">50</span>, <span class="kw">names</span>(VM))))
d.plot &lt;-<span class="st"> </span><span class="kw">cbind</span>(пол =<span class="st"> </span><span class="kw">rep</span>(<span class="st">&quot;F&quot;</span>, <span class="dv">50</span>), d.plot)
d.plot$диаметр &lt;-<span class="st"> </span><span class="kw">seq</span>(<span class="kw">min</span>(abalone$диаметр),
                      <span class="kw">max</span>(abalone$диаметр), <span class="dt">len =</span> <span class="dv">50</span>)
d.pplot &lt;-<span class="st"> </span><span class="kw">cbind</span>(d.plot, <span class="kw">predict</span>(CL.aq, <span class="dt">newdata =</span> d.plot,
                                 <span class="dt">type =</span> <span class="st">&quot;probs&quot;</span>, <span class="dt">se =</span> <span class="ot">TRUE</span>))
<span class="co">#   Прорисовка компонент графика</span>
<span class="kw">plot</span>(<span class="dv">1</span>, <span class="dv">1</span>, <span class="dt">xlim =</span> <span class="kw">c</span>(<span class="dv">0</span>, <span class="kw">max</span>(abalone$диаметр)), <span class="dt">ylim =</span> <span class="kw">c</span>(<span class="dv">0</span>, <span class="fl">0.8</span>),
     <span class="dt">type =</span> <span class="st">&#39;n&#39;</span>, <span class="dt">xlab =</span> <span class="st">&quot;Диаметр раковины&quot;</span>, <span class="dt">ylab =</span> <span class="st">&quot;Вероятность Р&quot;</span>)
<span class="kw">lines</span>(d.pplot[, <span class="kw">c</span>(<span class="dv">3</span>, <span class="dv">9</span>)], <span class="dt">lwd =</span> <span class="dv">2</span>, <span class="dt">col =</span> <span class="st">&quot;green&quot;</span>)
<span class="kw">lines</span>(d.pplot[, <span class="kw">c</span>(<span class="dv">3</span>, <span class="dv">10</span>)], <span class="dt">lwd =</span> <span class="dv">2</span>, <span class="dt">col =</span> <span class="st">&quot;blue&quot;</span>)
<span class="kw">lines</span>(d.pplot[, <span class="kw">c</span>(<span class="dv">3</span>, <span class="dv">11</span>)], <span class="dt">lwd =</span> <span class="dv">2</span>, <span class="dt">col =</span> <span class="st">&quot;black&quot;</span>)
<span class="kw">lines</span>(d.pplot[, <span class="kw">c</span>(<span class="dv">3</span>, <span class="dv">12</span>)], <span class="dt">lwd =</span> <span class="dv">2</span>, <span class="dt">col =</span> <span class="st">&quot;red&quot;</span>)
<span class="kw">legend</span>(<span class="st">&quot;topright&quot;</span>, <span class="kw">c</span>(<span class="st">&quot;Q1&quot;</span>, <span class="st">&quot;Q2&quot;</span>, <span class="st">&quot;Q3&quot;</span>, <span class="st">&quot;Q4&quot;</span>), <span class="dt">lwd =</span> <span class="dv">2</span>, 
       <span class="dt">col =</span> <span class="kw">c</span>(<span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">1</span>, <span class="dv">2</span>))</code></pre></div>
<div class="figure" style="text-align: center"><span id="fig:fig-8-5"></span>
<img src="081-Logit-for-Count_files/figure-html/fig-8-5-1.png" alt="Вероятности отнесения моллюсков к возрастным категориям в зависимость от диаметра раковины" width="576" />
<p class="caption">
Рисунок 8.5: Вероятности отнесения моллюсков к возрастным категориям в зависимость от диаметра раковины
</p>
</div>
<p>На рис. <a href="081-Logit-for-Count.html#fig:fig-8-5">8.5</a> видно, что экстремальные значения диаметра раковины соответствуют максимальным вероятностям отнесения к младшим и старшим возрастным категориям соответственно слева и справа. Промежуточные значения диаметра, вероятнее всего, приведут к средним возрастам <code>Q4</code> и <code>Q3</code>.</p>

</div>
            </section>

          </div>
        </div>
      </div>
<a href="076-NN.html" class="navigation navigation-prev " aria-label="Previous page"><i class="fa fa-angle-left"></i></a>
<a href="082-NN-with-Caret.html" class="navigation navigation-next " aria-label="Next page""><i class="fa fa-angle-right"></i></a>

<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/lunr.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script>
require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": false,
"facebook": true,
"twitter": true,
"google": false,
"weibo": false,
"instapper": false,
"vk": false,
"all": ["facebook", "google", "twitter", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": {
"link": null,
"text": null
},
"download": ["_main.epub"],
"toc": {
"collapse": "subsection"
}
});
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    if (location.protocol !== "file:" && /^https?:/.test(script.src))
      script.src  = script.src.replace(/^https?:/, '');
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>
</body>

</html>
